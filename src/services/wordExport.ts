export interface WordExportOptions {
  title: string;
  content: string;
  author?: string;
  includeMetadata?: boolean;
  includeWordCount?: boolean;
  fontSize?: number;
}

export interface AnalyticsExportOptions extends WordExportOptions {
  writingScore?: number;
  suggestions?: Array<{type: string; message: string; originalText: string}>;
  analytics?: {
    readingTime: string;
    sentenceCount: number;
    avgWordsPerSentence: number;
  };
}

export class WordExportService {
  /**
   * Export document content as an RTF file (opens in Word)
   */
  static async exportToWordWithFormatting(options: WordExportOptions): Promise<void> {
    const {
      title,
      content,
      author = 'WordWise AI User',
      includeMetadata = true,
      includeWordCount = true,
      fontSize = 12
    } = options;

    try {
      let rtfContent = this.createRTFHeader();
      
      // Add title
      rtfContent += `\\pard\\qc\\b\\fs${(fontSize + 6) * 2}${this.escapeRTF(title)}\\b0\\par\\par\n`;
      
      // Add metadata if enabled
      if (includeMetadata) {
        const currentDate = new Date().toLocaleDateString();
        const cleanContent = this.cleanHTMLContent(content);
        const wordCount = this.countWords(cleanContent);
        const charCount = cleanContent.length;
        
        rtfContent += `\\pard\\ql\\i\\fs${(fontSize - 2) * 2}\\cf1`;
        rtfContent += `Created: ${currentDate}\\par\n`;
        rtfContent += `Author: ${this.escapeRTF(author)}\\par\n`;
        
        if (includeWordCount) {
          rtfContent += `Words: ${wordCount} | Characters: ${charCount}\\par\n`;
        }
        
        rtfContent += `Generated by WordWise AI\\i0\\cf0\\par\\par\n`;
      }
      
      // Process and add content
      const formattedContent = this.parseHTMLToRTF(content, fontSize);
      rtfContent += formattedContent;
      
      // Close RTF
      rtfContent += '}';
      
      // Create and download file
      const fileName = `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.rtf`;
      this.downloadRTF(rtfContent, fileName);
      
      console.log(`✅ Word document exported successfully: ${fileName}`);
    } catch (error) {
      console.error('❌ Error exporting Word document:', error);
      throw new Error('Failed to export Word document. Please try again.');
    }
  }

  /**
   * Export document with comprehensive analytics
   */
  static async exportWithAnalytics(options: AnalyticsExportOptions): Promise<void> {
    const {
      title,
      content,
      author = 'WordWise AI User',
      writingScore,
      suggestions = [],
      analytics
    } = options;

    try {
      let rtfContent = this.createRTFHeader();
      
      // Title
      rtfContent += `\\pard\\qc\\b\\fs32${this.escapeRTF(title)} - Writing Analysis\\b0\\par\\par\\par\n`;
      
      // Writing Score Section
      if (writingScore !== undefined) {
        rtfContent += `\\pard\\ql\\b\\fs28 Writing Score\\b0\\par\n`;
        
        const scoreColor = writingScore >= 90 ? '\\cf2' : writingScore >= 70 ? '\\cf3' : '\\cf4';
        rtfContent += `\\pard\\ql\\b\\fs48${scoreColor}${writingScore}/100\\b0\\cf0\\par\\par\n`;
      }
      
      // Analytics Section
      if (analytics) {
        rtfContent += `\\pard\\ql\\b\\fs28 Document Statistics\\b0\\par\n`;
        
        const cleanContent = this.cleanHTMLContent(content);
        const wordCount = this.countWords(cleanContent);
        
        const stats = [
          `Word Count: ${wordCount}`,
          `Character Count: ${cleanContent.length}`,
          `Sentence Count: ${analytics.sentenceCount}`,
          `Average Words per Sentence: ${analytics.avgWordsPerSentence}`,
          `Estimated Reading Time: ${analytics.readingTime}`
        ];
        
        stats.forEach(stat => {
          rtfContent += `\\pard\\ql\\fs22 \\bullet ${this.escapeRTF(stat)}\\par\n`;
        });
        
        rtfContent += `\\par\n`;
      }
      
      // Suggestions Section
      if (suggestions.length > 0) {
        rtfContent += `\\pard\\ql\\b\\fs28 Improvement Suggestions\\b0\\par\n`;
        
        const suggestionsByType = suggestions.reduce((acc, suggestion) => {
          if (!acc[suggestion.type]) acc[suggestion.type] = [];
          acc[suggestion.type].push(suggestion);
          return acc;
        }, {} as Record<string, typeof suggestions>);
        
        for (const [type, typeSuggestions] of Object.entries(suggestionsByType)) {
          rtfContent += `\\pard\\ql\\b\\fs24 ${this.escapeRTF(type.charAt(0).toUpperCase() + type.slice(1))} (${typeSuggestions.length})\\b0\\par\n`;
          
          typeSuggestions.slice(0, 5).forEach(suggestion => {
            rtfContent += `\\pard\\ql\\fs20 \\bullet ${this.escapeRTF(suggestion.message)}\\par\n`;
          });
          
          rtfContent += `\\par\n`;
        }
      }
      
      // Document Content Section
      rtfContent += `\\pard\\ql\\b\\fs28 Document Content\\b0\\par\\par\n`;
      
      // Add the actual content
      const cleanContent = this.cleanHTMLContent(content);
      const contentParagraphs = cleanContent.split('\n\n').filter(p => p.trim());
      
      contentParagraphs.forEach(text => {
        rtfContent += `\\pard\\ql\\fs24 ${this.escapeRTF(text.trim())}\\par\\par\n`;
      });
      
      // Close RTF
      rtfContent += '}';
      
      // Create and download file
      const fileName = `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_analysis.rtf`;
      this.downloadRTF(rtfContent, fileName);
      
      console.log(`✅ Analytics Word document exported successfully: ${fileName}`);
    } catch (error) {
      console.error('❌ Error exporting analytics Word document:', error);
      throw new Error('Failed to export analytics Word document. Please try again.');
    }
  }

  /**
   * Create RTF header with color table and font table
   */
  private static createRTFHeader(): string {
    return `{\\rtf1\\ansi\\deff0 {\\fonttbl {\\f0\\froman\\fcharset0 Times New Roman;}}
{\\colortbl;\\red128\\green128\\blue128;\\red0\\green128\\blue0;\\red255\\green165\\blue0;\\red255\\green0\\blue0;}
\\f0\\fs24 `;
  }

  /**
   * Parse HTML content and convert to RTF format
   */
  private static parseHTMLToRTF(htmlContent: string, fontSize: number): string {
    let rtfContent = '';
    
    // Create a temporary div to parse HTML
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = htmlContent;
    
    // Get all elements or treat as plain text
    const elements = tempDiv.querySelectorAll('p, h1, h2, h3, h4, h5, h6, div, br');
    
    if (elements.length === 0) {
      // Plain text content
      const cleanText = this.cleanHTMLContent(htmlContent);
      const paragraphs = cleanText.split('\n\n').filter(p => p.trim());
      
      paragraphs.forEach(text => {
        rtfContent += `\\pard\\ql\\fs${fontSize * 2} ${this.escapeRTF(text.trim())}\\par\\par\n`;
      });
    } else {
      // Process HTML elements
      elements.forEach(element => {
        const text = element.textContent?.trim();
        if (!text && element.tagName !== 'BR') return;
        
        const tagName = element.tagName.toLowerCase();
        let fontSizeRTF = fontSize * 2;
        let isBold = false;
        
        switch (tagName) {
          case 'h1':
            fontSizeRTF = (fontSize + 8) * 2;
            isBold = true;
            break;
          case 'h2':
            fontSizeRTF = (fontSize + 6) * 2;
            isBold = true;
            break;
          case 'h3':
            fontSizeRTF = (fontSize + 4) * 2;
            isBold = true;
            break;
          case 'h4':
            fontSizeRTF = (fontSize + 2) * 2;
            isBold = true;
            break;
          case 'h5':
            fontSizeRTF = (fontSize + 1) * 2;
            isBold = true;
            break;
          case 'h6':
            fontSizeRTF = fontSize * 2;
            isBold = true;
            break;
          case 'br':
            rtfContent += `\\par\n`;
            return;
        }
        
        const boldStart = isBold ? '\\b ' : '';
        const boldEnd = isBold ? '\\b0' : '';
        
        if (text) {
          rtfContent += `\\pard\\ql${boldStart}\\fs${fontSizeRTF} ${this.escapeRTF(text)}${boldEnd}\\par\\par\n`;
        }
      });
    }
    
    return rtfContent;
  }

  /**
   * Clean HTML content and return plain text
   */
  private static cleanHTMLContent(htmlContent: string): string {
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = htmlContent;
    
    const textContent = tempDiv.textContent || tempDiv.innerText || '';
    
    return textContent
      .replace(/\s+/g, ' ')
      .replace(/\n\s*\n/g, '\n\n')
      .trim();
  }

  /**
   * Count words in text content
   */
  private static countWords(text: string): number {
    return text.trim() ? text.trim().split(/\s+/).length : 0;
  }

  /**
   * Escape special RTF characters
   */
  private static escapeRTF(text: string): string {
    return text
      .replace(/\\/g, '\\\\')
      .replace(/\{/g, '\\{')
      .replace(/\}/g, '\\}')
      .replace(/\n/g, '\\par ')
      .replace(/\r/g, '');
  }

  /**
   * Download RTF content as a file
   */
  private static downloadRTF(content: string, filename: string): void {
    const blob = new Blob([content], { type: 'application/rtf' });
    const url = URL.createObjectURL(blob);
    
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    link.style.display = 'none';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    URL.revokeObjectURL(url);
  }
} 